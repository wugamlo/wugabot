I want to enable Brave web-search for my app. The user workflow should be as follows:

User Interface: Include a toggle in the HTML frontend for users to decide if search is activated for the next message. This is a straightforward, user-friendly approach, ensuring control over API usage.
Backend Processing: On message submission, check the toggle state. If enabled, process the message to create a search query, perform the search, and format the combined text for the LLM. 

Only user message is appended to the chat history
LLM returns result considering the web search which is added to the chat history

I checked and there is a "brave-search" package available for python.
The Brave API key is stored in replit secrets as BRAVE_API_KEY

from brave import Brave
brave = Brave()
search_results = brave.search(q="your_query", count=10)


To avoid exceeding the free tier’s 2,000–5,000 monthly queries, implement caching to reduce API calls:
Python: Use lru_cache from functools for in-memory caching with a maximum size (e.g., 100 entries):
python
from functools import lru_cache
from brave import Brave

brave = Brave()
@lru_cache(maxsize=100)
def cached_search(query, count=10):
    return brave.search(q=query, count=count)
Set a time-to-live (e.g., 24 hours) to ensure freshness, especially for time-sensitive data, using libraries like dogpile.cache for advanced expiration.
For simplicity, use a dictionary for basic caching:
python
search_cache = {}
def perform_search(query):
    query = query.strip().lower()
    if query in search_cache:
        return search_cache[query]
    search_results = brave.search(q=query[:200], count=5)
    results_snippets = [result.description for result in search_results.web_results[:3]]
    search_cache[query] = '\n'.join(results_snippets)
    return search_cache[query]


Of course button logic needs to be handled and fetchChatResponse needs to include the searchEnabled in the request.

Please do not impact any other functionality of the app.